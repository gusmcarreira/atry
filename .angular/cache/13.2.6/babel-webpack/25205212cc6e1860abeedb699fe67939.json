{"ast":null,"code":"import _classCallCheck from \"/Users/gustavocarreira/Documents/GitHub/atry/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gustavocarreira/Documents/GitHub/atry/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EventEmitter } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { map, mergeMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport var ChatbotService = /*#__PURE__*/function () {\n  function ChatbotService(http) {\n    _classCallCheck(this, ChatbotService);\n\n    this.http = http;\n    this.messageUpdate = new EventEmitter();\n    this.senderID = Math.random().toString(36).substr(2);\n  } // Faz conecção com o RASA (reinicia a conversa --> /restart)\n\n\n  _createClass(ChatbotService, [{\n    key: \"initRasaChat\",\n    value: function initRasaChat(url, user) {\n      var _this = this;\n\n      var trackerEventsUrl = url + \"/conversations/\".concat(user, \"/tracker/events\");\n      return this.http.post(trackerEventsUrl, {\n        event: 'restart'\n      }).pipe(mergeMap(function () {\n        return _this.http.post(trackerEventsUrl, {\n          event: 'action',\n          name: 'action_listen'\n        });\n      }));\n    } // Manda as mensagens ao RASA\n    // url: para se conectar ao rasa\n    // user: id do user (necessário para o rasa) (estou a fazer de forma aleatória no chat-widget.component.ts)\n    // message: mensagem para mandar ao RASA\n    // mensagem para o error '/EXTERNAL_ERROR_MESSAGE{\"error_type\":\"Função\", \"error_message\":\"Faltou parêntesis\"}'\n    // x -> Função | Condicional | Variável | Repetição (model/errors/analise-pre-compilação/enum/tipoErro.ts)\n    // y -> Mensagem simplificada (model/errors/analise-pre-compilação/enum/tipoErros(...).ts)\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(url, user, message) {\n      if (typeof message !== 'string') {\n        var error_type = message.contexto.replace(\"\\n\", \"<new_line>\").replace(\"\\t\", \"<tab>\");\n        var error_message = message.mensagem.replace(\"\\n\", \"<new_line>\").replace(\"\\t\", \"<tab>\");\n        message = \"/EXTERNAL_ERROR_MESSAGE{\\\"error_type\\\":\\\"\".concat(error_type, \"\\\", \\\"error_message\\\":\\\"\").concat(error_message, \"\\\"}\");\n      }\n\n      var rasaMessageUrl = url + \"/webhooks/rest/webhook\";\n      this.latestMessageArr = this.http.post(rasaMessageUrl, {\n        message: message,\n        sender: user\n      }).pipe(map(function (responseMessages) {\n        return responseMessages.map(function (m) {\n          // Verifica se a resposta contém botões\n          if (m[\"buttons\"] !== undefined) {\n            // Botões vêem acompanhados de texto\n            if (m[\"text\"] !== undefined) {\n              return {\n                message: m[\"text\"],\n                buttons: m[\"buttons\"],\n                type: \"buttons\"\n              };\n            } // Apenas contém butões\n            else {\n              return {\n                buttons: m[\"buttons\"],\n                type: \"buttons\"\n              };\n            }\n          } else {\n            // O text é simples txt, o <code> e <code_print> foi escrito simplesmente para simbolizar\n            // Verificar se o texto contém código \n            if (m[\"text\"].includes(\"<code>\")) {\n              return {\n                message: m[\"text\"].replace(\"<code>\", \"\"),\n                type: \"code\"\n              };\n            } // Verificar se o texto contém a resposta do código  \n            else if (m[\"text\"].includes(\"<code_print>\")) {\n              return {\n                message: m[\"text\"].replace(\"<code_print>\", \"\"),\n                type: \"print\"\n              };\n            }\n\n            return {\n              message: m[\"text\"],\n              type: \"text\"\n            };\n          }\n        });\n      }));\n      this.messageUpdate.emit();\n    }\n  }]);\n\n  return ChatbotService;\n}();\n\nChatbotService.ɵfac = function ChatbotService_Factory(t) {\n  return new (t || ChatbotService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nChatbotService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ChatbotService,\n  factory: ChatbotService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/Users/gustavocarreira/Documents/GitHub/atry/src/app/chatbot/chatbot.service.ts"],"names":["EventEmitter","HttpClient","map","mergeMap","i0","i1","ChatbotService","http","messageUpdate","senderID","Math","random","toString","substr","url","user","trackerEventsUrl","post","event","pipe","name","message","error_type","contexto","replace","error_message","mensagem","rasaMessageUrl","latestMessageArr","sender","responseMessages","m","undefined","buttons","type","includes","emit","ɵfac","ChatbotService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { EventEmitter } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { map, mergeMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ChatbotService {\n    constructor(http) {\n        this.http = http;\n        this.messageUpdate = new EventEmitter();\n        this.senderID = Math.random()\n            .toString(36)\n            .substr(2);\n    }\n    // Faz conecção com o RASA (reinicia a conversa --> /restart)\n    initRasaChat(url, user) {\n        const trackerEventsUrl = url + `/conversations/${user}/tracker/events`;\n        return this.http\n            .post(trackerEventsUrl, {\n            event: 'restart'\n        })\n            .pipe(mergeMap(() => this.http.post(trackerEventsUrl, {\n            event: 'action',\n            name: 'action_listen'\n        })));\n    }\n    // Manda as mensagens ao RASA\n    // url: para se conectar ao rasa\n    // user: id do user (necessário para o rasa) (estou a fazer de forma aleatória no chat-widget.component.ts)\n    // message: mensagem para mandar ao RASA\n    // mensagem para o error '/EXTERNAL_ERROR_MESSAGE{\"error_type\":\"Função\", \"error_message\":\"Faltou parêntesis\"}'\n    // x -> Função | Condicional | Variável | Repetição (model/errors/analise-pre-compilação/enum/tipoErro.ts)\n    // y -> Mensagem simplificada (model/errors/analise-pre-compilação/enum/tipoErros(...).ts)\n    sendMessage(url, user, message) {\n        if (typeof message !== 'string') {\n            let error_type = message.contexto.replace(\"\\n\", \"<new_line>\").replace(\"\\t\", \"<tab>\");\n            let error_message = message.mensagem.replace(\"\\n\", \"<new_line>\").replace(\"\\t\", \"<tab>\");\n            message = `/EXTERNAL_ERROR_MESSAGE{\"error_type\":\"${error_type}\", \"error_message\":\"${error_message}\"}`;\n        }\n        const rasaMessageUrl = url + \"/webhooks/rest/webhook\";\n        this.latestMessageArr = this.http\n            .post(rasaMessageUrl, {\n            message,\n            sender: user,\n        })\n            .pipe(map((responseMessages) => responseMessages.map(m => {\n            // Verifica se a resposta contém botões\n            if (m[\"buttons\"] !== undefined) {\n                // Botões vêem acompanhados de texto\n                if (m[\"text\"] !== undefined) {\n                    return { message: m[\"text\"], buttons: m[\"buttons\"], type: \"buttons\" };\n                }\n                // Apenas contém butões\n                else {\n                    return { buttons: m[\"buttons\"], type: \"buttons\" };\n                }\n            }\n            else {\n                // O text é simples txt, o <code> e <code_print> foi escrito simplesmente para simbolizar\n                // Verificar se o texto contém código \n                if (m[\"text\"].includes(\"<code>\")) {\n                    return { message: m[\"text\"].replace(\"<code>\", \"\"), type: \"code\" };\n                }\n                // Verificar se o texto contém a resposta do código  \n                else if (m[\"text\"].includes(\"<code_print>\")) {\n                    return { message: m[\"text\"].replace(\"<code_print>\", \"\"), type: \"print\" };\n                }\n                return { message: m[\"text\"], type: \"text\" };\n            }\n        })));\n        this.messageUpdate.emit();\n    }\n}\nChatbotService.ɵfac = function ChatbotService_Factory(t) { return new (t || ChatbotService)(i0.ɵɵinject(i1.HttpClient)); };\nChatbotService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ChatbotService, factory: ChatbotService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}